// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"backend-go/internal/model"
)

func newSystemLoginLog(db *gorm.DB, opts ...gen.DOOption) systemLoginLog {
	_systemLoginLog := systemLoginLog{}

	_systemLoginLog.systemLoginLogDo.UseDB(db, opts...)
	_systemLoginLog.systemLoginLogDo.UseModel(&model.SystemLoginLog{})

	tableName := _systemLoginLog.systemLoginLogDo.TableName()
	_systemLoginLog.ALL = field.NewAsterisk(tableName)
	_systemLoginLog.ID = field.NewInt64(tableName, "id")
	_systemLoginLog.LogType = field.NewInt(tableName, "log_type")
	_systemLoginLog.TraceID = field.NewString(tableName, "trace_id")
	_systemLoginLog.UserID = field.NewInt64(tableName, "user_id")
	_systemLoginLog.UserType = field.NewInt(tableName, "user_type")
	_systemLoginLog.Username = field.NewString(tableName, "username")
	_systemLoginLog.Result = field.NewInt(tableName, "result")
	_systemLoginLog.UserIP = field.NewString(tableName, "user_ip")
	_systemLoginLog.UserAgent = field.NewString(tableName, "user_agent")
	_systemLoginLog.Creator = field.NewString(tableName, "creator")
	_systemLoginLog.Updater = field.NewString(tableName, "updater")
	_systemLoginLog.CreatedAt = field.NewTime(tableName, "create_time")
	_systemLoginLog.UpdatedAt = field.NewTime(tableName, "update_time")
	_systemLoginLog.DeletedAt = field.NewField(tableName, "deleted")

	_systemLoginLog.fillFieldMap()

	return _systemLoginLog
}

type systemLoginLog struct {
	systemLoginLogDo systemLoginLogDo

	ALL       field.Asterisk
	ID        field.Int64  // 日志编号
	LogType   field.Int    // 日志类型
	TraceID   field.String // 链路追踪编号
	UserID    field.Int64  // 用户编号
	UserType  field.Int    // 用户类型
	Username  field.String // 用户账号
	Result    field.Int    // 登录结果
	UserIP    field.String // 用户 IP
	UserAgent field.String // 浏览器 UA
	Creator   field.String // 创建者
	Updater   field.String // 更新者
	CreatedAt field.Time   // 创建时间
	UpdatedAt field.Time   // 更新时间
	DeletedAt field.Field  // 是否删除

	fieldMap map[string]field.Expr
}

func (s systemLoginLog) Table(newTableName string) *systemLoginLog {
	s.systemLoginLogDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s systemLoginLog) As(alias string) *systemLoginLog {
	s.systemLoginLogDo.DO = *(s.systemLoginLogDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *systemLoginLog) updateTableName(table string) *systemLoginLog {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.LogType = field.NewInt(table, "log_type")
	s.TraceID = field.NewString(table, "trace_id")
	s.UserID = field.NewInt64(table, "user_id")
	s.UserType = field.NewInt(table, "user_type")
	s.Username = field.NewString(table, "username")
	s.Result = field.NewInt(table, "result")
	s.UserIP = field.NewString(table, "user_ip")
	s.UserAgent = field.NewString(table, "user_agent")
	s.Creator = field.NewString(table, "creator")
	s.Updater = field.NewString(table, "updater")
	s.CreatedAt = field.NewTime(table, "create_time")
	s.UpdatedAt = field.NewTime(table, "update_time")
	s.DeletedAt = field.NewField(table, "deleted")

	s.fillFieldMap()

	return s
}

func (s *systemLoginLog) WithContext(ctx context.Context) ISystemLoginLogDo {
	return s.systemLoginLogDo.WithContext(ctx)
}

func (s systemLoginLog) TableName() string { return s.systemLoginLogDo.TableName() }

func (s systemLoginLog) Alias() string { return s.systemLoginLogDo.Alias() }

func (s systemLoginLog) Columns(cols ...field.Expr) gen.Columns {
	return s.systemLoginLogDo.Columns(cols...)
}

func (s *systemLoginLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *systemLoginLog) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 14)
	s.fieldMap["id"] = s.ID
	s.fieldMap["log_type"] = s.LogType
	s.fieldMap["trace_id"] = s.TraceID
	s.fieldMap["user_id"] = s.UserID
	s.fieldMap["user_type"] = s.UserType
	s.fieldMap["username"] = s.Username
	s.fieldMap["result"] = s.Result
	s.fieldMap["user_ip"] = s.UserIP
	s.fieldMap["user_agent"] = s.UserAgent
	s.fieldMap["creator"] = s.Creator
	s.fieldMap["updater"] = s.Updater
	s.fieldMap["create_time"] = s.CreatedAt
	s.fieldMap["update_time"] = s.UpdatedAt
	s.fieldMap["deleted"] = s.DeletedAt
}

func (s systemLoginLog) clone(db *gorm.DB) systemLoginLog {
	s.systemLoginLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s systemLoginLog) replaceDB(db *gorm.DB) systemLoginLog {
	s.systemLoginLogDo.ReplaceDB(db)
	return s
}

type systemLoginLogDo struct{ gen.DO }

type ISystemLoginLogDo interface {
	gen.SubQuery
	Debug() ISystemLoginLogDo
	WithContext(ctx context.Context) ISystemLoginLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISystemLoginLogDo
	WriteDB() ISystemLoginLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISystemLoginLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISystemLoginLogDo
	Not(conds ...gen.Condition) ISystemLoginLogDo
	Or(conds ...gen.Condition) ISystemLoginLogDo
	Select(conds ...field.Expr) ISystemLoginLogDo
	Where(conds ...gen.Condition) ISystemLoginLogDo
	Order(conds ...field.Expr) ISystemLoginLogDo
	Distinct(cols ...field.Expr) ISystemLoginLogDo
	Omit(cols ...field.Expr) ISystemLoginLogDo
	Join(table schema.Tabler, on ...field.Expr) ISystemLoginLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISystemLoginLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISystemLoginLogDo
	Group(cols ...field.Expr) ISystemLoginLogDo
	Having(conds ...gen.Condition) ISystemLoginLogDo
	Limit(limit int) ISystemLoginLogDo
	Offset(offset int) ISystemLoginLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISystemLoginLogDo
	Unscoped() ISystemLoginLogDo
	Create(values ...*model.SystemLoginLog) error
	CreateInBatches(values []*model.SystemLoginLog, batchSize int) error
	Save(values ...*model.SystemLoginLog) error
	First() (*model.SystemLoginLog, error)
	Take() (*model.SystemLoginLog, error)
	Last() (*model.SystemLoginLog, error)
	Find() ([]*model.SystemLoginLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SystemLoginLog, err error)
	FindInBatches(result *[]*model.SystemLoginLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SystemLoginLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISystemLoginLogDo
	Assign(attrs ...field.AssignExpr) ISystemLoginLogDo
	Joins(fields ...field.RelationField) ISystemLoginLogDo
	Preload(fields ...field.RelationField) ISystemLoginLogDo
	FirstOrInit() (*model.SystemLoginLog, error)
	FirstOrCreate() (*model.SystemLoginLog, error)
	FindByPage(offset int, limit int) (result []*model.SystemLoginLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISystemLoginLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s systemLoginLogDo) Debug() ISystemLoginLogDo {
	return s.withDO(s.DO.Debug())
}

func (s systemLoginLogDo) WithContext(ctx context.Context) ISystemLoginLogDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s systemLoginLogDo) ReadDB() ISystemLoginLogDo {
	return s.Clauses(dbresolver.Read)
}

func (s systemLoginLogDo) WriteDB() ISystemLoginLogDo {
	return s.Clauses(dbresolver.Write)
}

func (s systemLoginLogDo) Session(config *gorm.Session) ISystemLoginLogDo {
	return s.withDO(s.DO.Session(config))
}

func (s systemLoginLogDo) Clauses(conds ...clause.Expression) ISystemLoginLogDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s systemLoginLogDo) Returning(value interface{}, columns ...string) ISystemLoginLogDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s systemLoginLogDo) Not(conds ...gen.Condition) ISystemLoginLogDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s systemLoginLogDo) Or(conds ...gen.Condition) ISystemLoginLogDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s systemLoginLogDo) Select(conds ...field.Expr) ISystemLoginLogDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s systemLoginLogDo) Where(conds ...gen.Condition) ISystemLoginLogDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s systemLoginLogDo) Order(conds ...field.Expr) ISystemLoginLogDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s systemLoginLogDo) Distinct(cols ...field.Expr) ISystemLoginLogDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s systemLoginLogDo) Omit(cols ...field.Expr) ISystemLoginLogDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s systemLoginLogDo) Join(table schema.Tabler, on ...field.Expr) ISystemLoginLogDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s systemLoginLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISystemLoginLogDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s systemLoginLogDo) RightJoin(table schema.Tabler, on ...field.Expr) ISystemLoginLogDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s systemLoginLogDo) Group(cols ...field.Expr) ISystemLoginLogDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s systemLoginLogDo) Having(conds ...gen.Condition) ISystemLoginLogDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s systemLoginLogDo) Limit(limit int) ISystemLoginLogDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s systemLoginLogDo) Offset(offset int) ISystemLoginLogDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s systemLoginLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISystemLoginLogDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s systemLoginLogDo) Unscoped() ISystemLoginLogDo {
	return s.withDO(s.DO.Unscoped())
}

func (s systemLoginLogDo) Create(values ...*model.SystemLoginLog) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s systemLoginLogDo) CreateInBatches(values []*model.SystemLoginLog, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s systemLoginLogDo) Save(values ...*model.SystemLoginLog) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s systemLoginLogDo) First() (*model.SystemLoginLog, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SystemLoginLog), nil
	}
}

func (s systemLoginLogDo) Take() (*model.SystemLoginLog, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SystemLoginLog), nil
	}
}

func (s systemLoginLogDo) Last() (*model.SystemLoginLog, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SystemLoginLog), nil
	}
}

func (s systemLoginLogDo) Find() ([]*model.SystemLoginLog, error) {
	result, err := s.DO.Find()
	return result.([]*model.SystemLoginLog), err
}

func (s systemLoginLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SystemLoginLog, err error) {
	buf := make([]*model.SystemLoginLog, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s systemLoginLogDo) FindInBatches(result *[]*model.SystemLoginLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s systemLoginLogDo) Attrs(attrs ...field.AssignExpr) ISystemLoginLogDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s systemLoginLogDo) Assign(attrs ...field.AssignExpr) ISystemLoginLogDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s systemLoginLogDo) Joins(fields ...field.RelationField) ISystemLoginLogDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s systemLoginLogDo) Preload(fields ...field.RelationField) ISystemLoginLogDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s systemLoginLogDo) FirstOrInit() (*model.SystemLoginLog, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SystemLoginLog), nil
	}
}

func (s systemLoginLogDo) FirstOrCreate() (*model.SystemLoginLog, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SystemLoginLog), nil
	}
}

func (s systemLoginLogDo) FindByPage(offset int, limit int) (result []*model.SystemLoginLog, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s systemLoginLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s systemLoginLogDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s systemLoginLogDo) Delete(models ...*model.SystemLoginLog) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *systemLoginLogDo) withDO(do gen.Dao) *systemLoginLogDo {
	s.DO = *do.(*gen.DO)
	return s
}
