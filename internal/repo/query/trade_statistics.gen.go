// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"backend-go/internal/model/trade"
)

func newTradeStatistics(db *gorm.DB, opts ...gen.DOOption) tradeStatistics {
	_tradeStatistics := tradeStatistics{}

	_tradeStatistics.tradeStatisticsDo.UseDB(db, opts...)
	_tradeStatistics.tradeStatisticsDo.UseModel(&trade.TradeStatistics{})

	tableName := _tradeStatistics.tradeStatisticsDo.TableName()
	_tradeStatistics.ALL = field.NewAsterisk(tableName)
	_tradeStatistics.ID = field.NewInt64(tableName, "id")
	_tradeStatistics.Time = field.NewTime(tableName, "time")
	_tradeStatistics.OrderCreateCount = field.NewInt(tableName, "order_create_count")
	_tradeStatistics.OrderPayCount = field.NewInt(tableName, "order_pay_count")
	_tradeStatistics.OrderPayPrice = field.NewInt(tableName, "order_pay_price")
	_tradeStatistics.AfterSaleCount = field.NewInt(tableName, "after_sale_count")
	_tradeStatistics.AfterSaleRefundPrice = field.NewInt(tableName, "after_sale_refund_price")
	_tradeStatistics.BrokerageSettlementPrice = field.NewInt(tableName, "brokerage_settlement_price")
	_tradeStatistics.WalletPayPrice = field.NewInt(tableName, "wallet_pay_price")
	_tradeStatistics.RechargePayCount = field.NewInt(tableName, "recharge_pay_count")
	_tradeStatistics.RechargePayPrice = field.NewInt(tableName, "recharge_pay_price")
	_tradeStatistics.RechargeRefundCount = field.NewInt(tableName, "recharge_refund_count")
	_tradeStatistics.RechargeRefundPrice = field.NewInt(tableName, "recharge_refund_price")
	_tradeStatistics.Creator = field.NewString(tableName, "creator")
	_tradeStatistics.Updater = field.NewString(tableName, "updater")
	_tradeStatistics.CreatedAt = field.NewTime(tableName, "create_time")
	_tradeStatistics.UpdatedAt = field.NewTime(tableName, "update_time")
	_tradeStatistics.Deleted = field.NewBool(tableName, "deleted")

	_tradeStatistics.fillFieldMap()

	return _tradeStatistics
}

type tradeStatistics struct {
	tradeStatisticsDo tradeStatisticsDo

	ALL                      field.Asterisk
	ID                       field.Int64  // 编号
	Time                     field.Time   // 统计日期
	OrderCreateCount         field.Int    // 创建订单数
	OrderPayCount            field.Int    // 支付订单商品数
	OrderPayPrice            field.Int    // 总支付金额(分)
	AfterSaleCount           field.Int    // 退款订单数
	AfterSaleRefundPrice     field.Int    // 总退款金额(分)
	BrokerageSettlementPrice field.Int    // 佣金金额已结算(分)
	WalletPayPrice           field.Int    // 总支付金额余额(分)
	RechargePayCount         field.Int    // 充值订单数
	RechargePayPrice         field.Int    // 充值金额(分)
	RechargeRefundCount      field.Int    // 充值退款订单数
	RechargeRefundPrice      field.Int    // 充值退款金额(分)
	Creator                  field.String // 创建者
	Updater                  field.String // 更新者
	CreatedAt                field.Time   // 创建时间
	UpdatedAt                field.Time   // 更新时间
	Deleted                  field.Bool   // 是否删除

	fieldMap map[string]field.Expr
}

func (t tradeStatistics) Table(newTableName string) *tradeStatistics {
	t.tradeStatisticsDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tradeStatistics) As(alias string) *tradeStatistics {
	t.tradeStatisticsDo.DO = *(t.tradeStatisticsDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tradeStatistics) updateTableName(table string) *tradeStatistics {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.Time = field.NewTime(table, "time")
	t.OrderCreateCount = field.NewInt(table, "order_create_count")
	t.OrderPayCount = field.NewInt(table, "order_pay_count")
	t.OrderPayPrice = field.NewInt(table, "order_pay_price")
	t.AfterSaleCount = field.NewInt(table, "after_sale_count")
	t.AfterSaleRefundPrice = field.NewInt(table, "after_sale_refund_price")
	t.BrokerageSettlementPrice = field.NewInt(table, "brokerage_settlement_price")
	t.WalletPayPrice = field.NewInt(table, "wallet_pay_price")
	t.RechargePayCount = field.NewInt(table, "recharge_pay_count")
	t.RechargePayPrice = field.NewInt(table, "recharge_pay_price")
	t.RechargeRefundCount = field.NewInt(table, "recharge_refund_count")
	t.RechargeRefundPrice = field.NewInt(table, "recharge_refund_price")
	t.Creator = field.NewString(table, "creator")
	t.Updater = field.NewString(table, "updater")
	t.CreatedAt = field.NewTime(table, "create_time")
	t.UpdatedAt = field.NewTime(table, "update_time")
	t.Deleted = field.NewBool(table, "deleted")

	t.fillFieldMap()

	return t
}

func (t *tradeStatistics) WithContext(ctx context.Context) ITradeStatisticsDo {
	return t.tradeStatisticsDo.WithContext(ctx)
}

func (t tradeStatistics) TableName() string { return t.tradeStatisticsDo.TableName() }

func (t tradeStatistics) Alias() string { return t.tradeStatisticsDo.Alias() }

func (t tradeStatistics) Columns(cols ...field.Expr) gen.Columns {
	return t.tradeStatisticsDo.Columns(cols...)
}

func (t *tradeStatistics) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tradeStatistics) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 18)
	t.fieldMap["id"] = t.ID
	t.fieldMap["time"] = t.Time
	t.fieldMap["order_create_count"] = t.OrderCreateCount
	t.fieldMap["order_pay_count"] = t.OrderPayCount
	t.fieldMap["order_pay_price"] = t.OrderPayPrice
	t.fieldMap["after_sale_count"] = t.AfterSaleCount
	t.fieldMap["after_sale_refund_price"] = t.AfterSaleRefundPrice
	t.fieldMap["brokerage_settlement_price"] = t.BrokerageSettlementPrice
	t.fieldMap["wallet_pay_price"] = t.WalletPayPrice
	t.fieldMap["recharge_pay_count"] = t.RechargePayCount
	t.fieldMap["recharge_pay_price"] = t.RechargePayPrice
	t.fieldMap["recharge_refund_count"] = t.RechargeRefundCount
	t.fieldMap["recharge_refund_price"] = t.RechargeRefundPrice
	t.fieldMap["creator"] = t.Creator
	t.fieldMap["updater"] = t.Updater
	t.fieldMap["create_time"] = t.CreatedAt
	t.fieldMap["update_time"] = t.UpdatedAt
	t.fieldMap["deleted"] = t.Deleted
}

func (t tradeStatistics) clone(db *gorm.DB) tradeStatistics {
	t.tradeStatisticsDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tradeStatistics) replaceDB(db *gorm.DB) tradeStatistics {
	t.tradeStatisticsDo.ReplaceDB(db)
	return t
}

type tradeStatisticsDo struct{ gen.DO }

type ITradeStatisticsDo interface {
	gen.SubQuery
	Debug() ITradeStatisticsDo
	WithContext(ctx context.Context) ITradeStatisticsDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITradeStatisticsDo
	WriteDB() ITradeStatisticsDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITradeStatisticsDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITradeStatisticsDo
	Not(conds ...gen.Condition) ITradeStatisticsDo
	Or(conds ...gen.Condition) ITradeStatisticsDo
	Select(conds ...field.Expr) ITradeStatisticsDo
	Where(conds ...gen.Condition) ITradeStatisticsDo
	Order(conds ...field.Expr) ITradeStatisticsDo
	Distinct(cols ...field.Expr) ITradeStatisticsDo
	Omit(cols ...field.Expr) ITradeStatisticsDo
	Join(table schema.Tabler, on ...field.Expr) ITradeStatisticsDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITradeStatisticsDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITradeStatisticsDo
	Group(cols ...field.Expr) ITradeStatisticsDo
	Having(conds ...gen.Condition) ITradeStatisticsDo
	Limit(limit int) ITradeStatisticsDo
	Offset(offset int) ITradeStatisticsDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITradeStatisticsDo
	Unscoped() ITradeStatisticsDo
	Create(values ...*trade.TradeStatistics) error
	CreateInBatches(values []*trade.TradeStatistics, batchSize int) error
	Save(values ...*trade.TradeStatistics) error
	First() (*trade.TradeStatistics, error)
	Take() (*trade.TradeStatistics, error)
	Last() (*trade.TradeStatistics, error)
	Find() ([]*trade.TradeStatistics, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*trade.TradeStatistics, err error)
	FindInBatches(result *[]*trade.TradeStatistics, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*trade.TradeStatistics) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITradeStatisticsDo
	Assign(attrs ...field.AssignExpr) ITradeStatisticsDo
	Joins(fields ...field.RelationField) ITradeStatisticsDo
	Preload(fields ...field.RelationField) ITradeStatisticsDo
	FirstOrInit() (*trade.TradeStatistics, error)
	FirstOrCreate() (*trade.TradeStatistics, error)
	FindByPage(offset int, limit int) (result []*trade.TradeStatistics, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITradeStatisticsDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tradeStatisticsDo) Debug() ITradeStatisticsDo {
	return t.withDO(t.DO.Debug())
}

func (t tradeStatisticsDo) WithContext(ctx context.Context) ITradeStatisticsDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tradeStatisticsDo) ReadDB() ITradeStatisticsDo {
	return t.Clauses(dbresolver.Read)
}

func (t tradeStatisticsDo) WriteDB() ITradeStatisticsDo {
	return t.Clauses(dbresolver.Write)
}

func (t tradeStatisticsDo) Session(config *gorm.Session) ITradeStatisticsDo {
	return t.withDO(t.DO.Session(config))
}

func (t tradeStatisticsDo) Clauses(conds ...clause.Expression) ITradeStatisticsDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tradeStatisticsDo) Returning(value interface{}, columns ...string) ITradeStatisticsDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tradeStatisticsDo) Not(conds ...gen.Condition) ITradeStatisticsDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tradeStatisticsDo) Or(conds ...gen.Condition) ITradeStatisticsDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tradeStatisticsDo) Select(conds ...field.Expr) ITradeStatisticsDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tradeStatisticsDo) Where(conds ...gen.Condition) ITradeStatisticsDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tradeStatisticsDo) Order(conds ...field.Expr) ITradeStatisticsDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tradeStatisticsDo) Distinct(cols ...field.Expr) ITradeStatisticsDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tradeStatisticsDo) Omit(cols ...field.Expr) ITradeStatisticsDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tradeStatisticsDo) Join(table schema.Tabler, on ...field.Expr) ITradeStatisticsDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tradeStatisticsDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITradeStatisticsDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tradeStatisticsDo) RightJoin(table schema.Tabler, on ...field.Expr) ITradeStatisticsDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tradeStatisticsDo) Group(cols ...field.Expr) ITradeStatisticsDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tradeStatisticsDo) Having(conds ...gen.Condition) ITradeStatisticsDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tradeStatisticsDo) Limit(limit int) ITradeStatisticsDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tradeStatisticsDo) Offset(offset int) ITradeStatisticsDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tradeStatisticsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITradeStatisticsDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tradeStatisticsDo) Unscoped() ITradeStatisticsDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tradeStatisticsDo) Create(values ...*trade.TradeStatistics) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tradeStatisticsDo) CreateInBatches(values []*trade.TradeStatistics, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tradeStatisticsDo) Save(values ...*trade.TradeStatistics) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tradeStatisticsDo) First() (*trade.TradeStatistics, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*trade.TradeStatistics), nil
	}
}

func (t tradeStatisticsDo) Take() (*trade.TradeStatistics, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*trade.TradeStatistics), nil
	}
}

func (t tradeStatisticsDo) Last() (*trade.TradeStatistics, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*trade.TradeStatistics), nil
	}
}

func (t tradeStatisticsDo) Find() ([]*trade.TradeStatistics, error) {
	result, err := t.DO.Find()
	return result.([]*trade.TradeStatistics), err
}

func (t tradeStatisticsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*trade.TradeStatistics, err error) {
	buf := make([]*trade.TradeStatistics, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tradeStatisticsDo) FindInBatches(result *[]*trade.TradeStatistics, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tradeStatisticsDo) Attrs(attrs ...field.AssignExpr) ITradeStatisticsDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tradeStatisticsDo) Assign(attrs ...field.AssignExpr) ITradeStatisticsDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tradeStatisticsDo) Joins(fields ...field.RelationField) ITradeStatisticsDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tradeStatisticsDo) Preload(fields ...field.RelationField) ITradeStatisticsDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tradeStatisticsDo) FirstOrInit() (*trade.TradeStatistics, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*trade.TradeStatistics), nil
	}
}

func (t tradeStatisticsDo) FirstOrCreate() (*trade.TradeStatistics, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*trade.TradeStatistics), nil
	}
}

func (t tradeStatisticsDo) FindByPage(offset int, limit int) (result []*trade.TradeStatistics, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tradeStatisticsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tradeStatisticsDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tradeStatisticsDo) Delete(models ...*trade.TradeStatistics) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tradeStatisticsDo) withDO(do gen.Dao) *tradeStatisticsDo {
	t.DO = *do.(*gen.DO)
	return t
}
